1. Bitmap para Gerenciamento de Memória
	•	Use um bitmap em vez de um vetor de estruturas para representar a disponibilidade dos quadros de memória.
	•	No bitmap, cada bit representa um quadro de memória:
	•	0: Quadro livre
	•	1: Quadro ocupado
	•	Vantagens:
	•	Reduz o uso de memória (um bit por quadro, em vez de uma estrutura inteira).
	•	A busca por N quadros consecutivos pode ser otimizada usando operações em nível de bit.
	•	Implementação:
	•	Use uma máscara deslizante (bitwise AND) para procurar sequências de bits livres.
	•	Quando encontrar uma sequência de N bits livres, marque-os como ocupados.
	•	Código Exemplo:


#include <vector>
#include <bitset>

const int NUM_QUADROS = 8192; // 32GB / 4MB
std::bitset<NUM_QUADROS> memoria; // 0 = livre, 1 = ocupado

int buscarQuadrosLivres(int N) {
    int count = 0, start = -1;

    for (int i = 0; i < NUM_QUADROS; i++) {
        if (!memoria[i]) { // Quadro livre
            if (count == 0) start = i; // Início da sequência
            count++;
            if (count == N) return start; // Encontrou N quadros livres
        } else {
            count = 0; // Reinicia busca
        }
    }
    return -1; // Sem espaço contíguo suficiente
}

void alocarQuadros(int start, int N) {
    for (int i = start; i < start + N; i++) memoria.set(i);
}

void liberarQuadros(int start, int N) {
    for (int i = start; i < start + N; i++) memoria.reset(i);
}


2. Estrutura de Dados com Intervalos Livres (Lista ou Heap)
	•	Descrição:
	•	Mantenha uma lista ordenada ou uma heap de intervalos livres.
	•	Cada elemento representaria um intervalo contínuo de quadros livres, com início e tamanho.
	•	Operações:
	•	Inserção de Processo: Procure um intervalo onde tamanho >= N e divida-o.
	•	Liberação de Processo: Ao liberar quadros, mescle os intervalos contíguos para evitar fragmentação.
	•	Vantagens:
	•	Reduz a necessidade de percorrer o vetor sequencialmente.
	•	A estrutura lida melhor com fragmentação de memória.
	•	Desvantagens:
	•	Manutenção da lista de intervalos pode ser custosa se não for implementada corretamente.
	•	Código Exemplo:


#include <set>

struct Intervalo {
    int inicio, tamanho;
    bool operator<(const Intervalo& other) const {
        return inicio < other.inicio;
    }
};

std::set<Intervalo> memoriaLivre;

void inicializarMemoria() {
    memoriaLivre.insert({0, 8192}); // Toda memória começa livre
}

int alocarQuadros(int N) {
    for (auto it = memoriaLivre.begin(); it != memoriaLivre.end(); ++it) {
        if (it->tamanho >= N) {
            int inicio = it->inicio;
            memoriaLivre.erase(it);
            if (it->tamanho > N) {
                memoriaLivre.insert({inicio + N, it->tamanho - N});
            }
            return inicio;
        }
    }
    return -1; // Falha ao alocar
}

void liberarQuadros(int inicio, int N) {
    memoriaLivre.insert({inicio, N});

    // Mesclar intervalos contíguos
    auto it = memoriaLivre.find({inicio, N});
    if (it != memoriaLivre.begin()) {
        auto prev = std::prev(it);
        if (prev->inicio + prev->tamanho == it->inicio) {
            N += prev->tamanho;
            inicio = prev->inicio;
            memoriaLivre.erase(prev);
            memoriaLivre.erase(it);
            it = memoriaLivre.insert({inicio, N}).first;
        }
    }
    auto next = std::next(it);
    if (next != memoriaLivre.end() && it->inicio + it->tamanho == next->inicio) {
        N += next->tamanho;
        memoriaLivre.erase(it);
        memoriaLivre.erase(next);
        memoriaLivre.insert({inicio, N});
    }
}



3. Melhoria no Algoritmo de Busca
	•	Se você optar por manter o vetor de estruturas, pode usar algoritmos eficientes para busca de sequências:
	•	Sliding Window: Uma janela deslizante mantém o número de quadros livres consecutivos.
	•	Segment Tree: Mantém uma árvore segmentada para representar os blocos livres, facilitando buscas rápidas.


    Comparação das Abordagens:

    Abordagem	Vantagens	Desvantagens
    Bitmap	Rápido, pouco uso de memória	Procura sequencial pode existir
    Lista de Intervalos	Eficiência em fragmentação	Maior complexidade de gerenciamento
    Vetor + Sliding Window	Simples e direto	Pode ser ineficiente em alta carga
    Segment Tree (Avançado)	Busca rápida de N quadros livres	Complexidade de implementação


Escolha da Abordagem
	•	Se o número de quadros for grande e a performance for crítica, recomendo bitmap ou lista de intervalos.
	•	Caso contrário, seu método original com um vetor de estruturas pode ser suficiente, especialmente se implementado com otimizações simples como sliding window.


SLIDING WINDOW USANDO STRUCT:

#include <iostream>
#include <vector>

struct Quadro {
    bool ocupado;
    void* processo; // Ponteiro para o processo associado (ou nullptr)
};

const int NUM_QUADROS = 8192; // 32GB / 4MB

// Função para buscar N quadros livres consecutivos usando Sliding Window
int buscarQuadrosLivres(std::vector<Quadro>& memoria, int N) {
    int start = -1; // Início da sequência atual
    int count = 0;  // Número de quadros livres consecutivos encontrados

    for (int i = 0; i < memoria.size(); ++i) {
        if (!memoria[i].ocupado) { // Quadro está livre
            if (start == -1) start = i; // Marca o início da sequência
            count++;
            if (count == N) return start; // Sequência suficiente encontrada
        } else {
            // Reinicia a busca
            start = -1;
            count = 0;
        }
    }

    return -1; // Nenhuma sequência de N quadros foi encontrada
}

// Função para alocar os quadros
void alocarQuadros(std::vector<Quadro>& memoria, int start, int N, void* processo) {
    for (int i = start; i < start + N; ++i) {
        memoria[i].ocupado = true;
        memoria[i].processo = processo;
    }
}

// Função para liberar os quadros
void liberarQuadros(std::vector<Quadro>& memoria, int start, int N) {
    for (int i = start; i < start + N; ++i) {
        memoria[i].ocupado = false;
        memoria[i].processo = nullptr;
    }
}

int main() {
    // Inicializa a memória (8192 quadros)
    std::vector<Quadro> memoria(NUM_QUADROS, {false, nullptr});

    // Simula alocação de um processo
    int tamanhoProcesso = 16; // Exemplo: processo precisa de 16 MB -> 4 quadros
    int N = tamanhoProcesso / 4; // N = 4

    int start = buscarQuadrosLivres(memoria, N);
    if (start != -1) {
        std::cout << "Quadros livres encontrados a partir de: " << start << "\n";
        alocarQuadros(memoria, start, N, (void*)0x1234); // Exemplo de ponteiro de processo
    } else {
        std::cout << "Falha ao alocar quadros.\n";
    }

    // Simula liberação de quadros
    liberarQuadros(memoria, start, N);
    std::cout << "Quadros liberados a partir de: " << start << "\n";

    return 0;
}

